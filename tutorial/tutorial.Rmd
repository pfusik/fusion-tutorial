---
title: Tutorial of the Fusion Programming Language (WIP)
author: Detlef Groth, University of Potsdam
date: 2026-01-29 16:12
---

`include tutorial.toc`

## Introduction

[Fusion](https://fusion-lang.org/) is a programming language which works as a transpiler, a tool which
translates code in the Fusion programming language into code of the
programming languages C, C++, C#, D, Java, Javascript, Python, Swift, Typescript and OpenCL.

<center>
![Diagram](https://kroki.io/graphviz/svg/eNptUMFOAyEQvfcrJvWiKbrqHS_bejBGjfbW9MAu0zIphRXY1o3pv8sC0R4kZCbMvPfmDZK2TnQK5vA9gXjSa6XFYPvAw9F2xJy1gdeLl-XifZ0wxkpc-TBo5BvSGiUbU2u1ddwLvbeGeSU65I39YkeSQfG7m9vMdcLsPHb8HqoKPIZYkNR7BmTibRX6DPubCSMSfRCNJq8gKIRLMgfy1Gi8ghZNQJc8JWZVodwiFH8JmCdntbhag5o_9p5-bbbkWo3nS-yGRve4LoKF-o9m2QE_e5IULZoWQWid3HjYOLsv3DMHcP1Q_nosMZjWs9l0TBcxzhk8iYPI0beOusDehqCiV_g40iYwWA4dlg68dmjq56iT9E5Z9Xx_bzXJ9SQ3JqcfG_ia7w==)

[Edit this diagram](https://niolesk.top/#https://kroki.io/graphviz/svg/eNptUMFOAyEQvfcrJvWiKbrqHS_bejBGjfbW9MAu0zIphRXY1o3pv8sC0R4kZCbMvPfmDZK2TnQK5vA9gXjSa6XFYPvAw9F2xJy1gdeLl-XifZ0wxkpc-TBo5BvSGiUbU2u1ddwLvbeGeSU65I39YkeSQfG7m9vMdcLsPHb8HqoKPIZYkNR7BmTibRX6DPubCSMSfRCNJq8gKIRLMgfy1Gi8ghZNQJc8JWZVodwiFH8JmCdntbhag5o_9p5-bbbkWo3nS-yGRve4LoKF-o9m2QE_e5IULZoWQWid3HjYOLsv3DMHcP1Q_nosMZjWs9l0TBcxzhk8iYPI0beOusDehqCiV_g40iYwWA4dlg68dmjq56iT9E5Z9Xx_bzXJ9SQ3JqcfG_ia7w==)
</center>

For background on the difference between compilers and transpilers have a
look at this [Geeks For Geeks Article](https://www.geeksforgeeks.org/compiler-design/difference-between-transpiler-and-compiler/).

## Installation

The transpiler for Fusion code is the [fut command line application](https://github.com/fusionlanguage/fut).
There are binaries available for Intel/AMD systems for Linux, MacOS and Windows systems. You should download the latest version for your platform from the [release page](https://github.com/fusionlanguage/fut/releases/).
Here an example for a Debian like system using the
[dpkg](https://www.linuxbash.sh/post/using-dpkg-to-manually-install-deb-packages)
command line application:

```
VERSION=fut-3.2.13
wget https://github.com/fusionlanguage/fut/releases/download/${V}/${V}-1_amd64.deb
sudo dpkg -i ${V}-1_amd64.deb
```

For MacOS you would use the Brew package manager:

```
brew install fusionlanguage/fut/fut
```

## Hello World Example

As usually we start with the standard "Hello World!" example. 

Fusion is not meant to write real programs, but libraries which can be then
used in the aforementioned programming languages. Still Fusion supports the
creation of simple command line applications, so here is our example and the expected output:

```{.shell label=Main cmd="fuscript %i > %b.txt" chunk.ext=fu ext=txt}
public static class Main {
    public static void Main () {
        Console.WriteLine("Hello World!");
    }   
}
```

The fusion source code can be translated into the target programming language.
Here an example for translating it into Python code and then executing it:

```
fut Main.fu -o out/main.py
python3 out/main.py
```

The Python output looks like this:

`include Main.py {{<pre class="py">} {</pre>}}` 


To compile to other targets you just have to change the file extension. Here an example to create D code:

```
fut Main.fu -o out/main.d
dmd out/main.d -of=out/main
./out/main 
Hello World!
```

The D language output looks like this:

`include out/main.d {{<pre class="py">} {</pre>}}` 


## Fusion Script Interpreter

In this tutorial we will use Python to directly execute the generated code
and embed the output into the document. For this we will use a little Bash
Script which generates Python code and then, thereafter, executes the generated script.

The Bash script looks like this:

```{.shell eval=FALSE,include=FALSE}
#INCLUDE "fuscript.sh"
```

## Other Programming Languages

### Lua

The output generated by the Fusion tool can be as well used to support even
more programming languages than the target languages of _fut_. For instance
we can use a transpiler for Typescript code to generate not only code for
different Javascript interpreters but as well create for instance Lua code
from that Typescript output. We can as an example create Lua scripts from Typescript code by using the TypescriptToLua transpiler [(tstl)](https://github.com/TypeScriptToLua/TypeScriptToLua). So the workflow is than the following:

```{.kroki label=tstl,dia=graphviz,echo=FALSE}
digraph g {
    rankdir="LR"
    node[shape=doc,style=filled,fillcolor=grey90,width=1.2]
    "Hello.fu" -> "hello.ts"[label=fut]
    "hello.ts" -> "hello.lua"[label="npx tstl"]
}
```

Let's create a simple library file, _Hello.fu_ in a sub folder _assets_:_


`include assets/Hello.fu {<pre> </pre>}`

And now a Lua file to use that library:

`include assets/run-hello-tstl.lua {<pre> </pre>}`


So a Makefile section for that conversion looks like this:

```{.shell label=tstlex,cmd="bash %i > %b.txt",chunk.ext=sh,ext=txt}
### npm install -D typescript-to-lua
fut -o assets/hello.ts assets/Hello.fu
npx tstl assets/hello.ts
cd assets && lua run-hello-tstl.lua
```

BTW: The file created by _tstl_ from the Typescript code looks like this:

`include assets/hello.lua {<pre> </pre>}`

The file *lualib_bundle.lua* imported here is a 82kb file which supports the
mapping from Typescript to Lua code.

### V-lang

More important for using our Fusion code library is the C code output. As C
code can be easily used by other programming languages we might as well use
the C output to use that in other programming languages. Here an example
using the [V Programming Language](https://vlang.io/). To use the libary we
include the C header file and declare all functions we like to use from the
library file. So for the same file _Hello.fu_ show above we create the
following V file.

`include assets/hello.v {<pre> </pre>}`

In this case we will create a shared library from the hello file and then run
our file _hello.v_ like this:

```{.shell label=vhello,cmd="bash %i > %b.txt",chunk.ext=sh,ext=txt}
fut -o assets/hello.c assets/Hello.fu
cd assets 
gcc -shared hello.c -o libhello.so
LD_LIBRARY_PATH=. v run hello.v
cd ..
```

So we are not limited to the target languages for Fusion using the nicely
structured output we can as well use transpilers for that output or simply
embed the C code in other programming languages. As C is the lingua franca of
programming it should be possible with more or less effort to use the
generated code. There are existing as well other interface generators, for example Swig which we will present later.

### Dart

In the Dart programming language we use the ffi package to call functions in
compiled C libraries. So we can use the same file we used in for the V
language. The project file for our Dart program using our hello library would look likes this:

`include assets/pubspec.yaml {<pre> </pre>}`

and the code to exectue these functions would look like this:


`include assets/hello.dart {<pre> </pre>}`


Our command line is the very simple:

```{.shell label=darthello,cmd="bash %i > %b.txt",chunk.ext=sh,ext=txt}
fut -o assets/hello.c assets/Hello.fu
cd assets 
gcc -shared hello.c -o libhello.so
LD_LIBRARY_PATH=. dart run hello.dart
cd ..
```

So, we can see that we can support as well other language as the _fut_
transpiler should output clean C code which can be then used in even more programming
languages. 

### Swig - Simplified Wrapper and Interface Generator

This manual creation of interfaces however is slightly cumbersome, so an
automated process of creating an interface for the C library would offer a
good alternative way. For instance the [Rust programming language](https://rust-lang.org/)
has a tool called [bindgen](https://github.com/rust-lang/rust-bindgen) to
simplify this process. Further there exists a tool called [Swig](https://swig.org) which automates this process for more than a dozen target languages. A few of these languages like C#, D, Java or Python are already directly supported by Fusion. Although it might be interested to get a fast implementation by using the C library made be usable by Swig than the Fusion Python output as the C library approach might be much faster than the Python code directly transpiled by the _fut_ tool.

For illustrative purposes let's create bindings for two scripting languages, Lua and Tcl for our little hello library shown above.

### Swig and Lua 

Let's start with Lua. The process of creating a wrapper for a C library using
Swig is usually started by creating an interface file which includes the
Header file of the C library. In a second section we declare the functions we
would like to use from that include file. Alternatively we can include here
the header file again to indicate that we would like to use all C functions
published in the header file. Afterwards we use Swig to create an interface C file, the original C and this wrapper file are then compiled either to a dynamic library or a static output file. For scripting languages we usually create a static library. So the process is as follows:


```{.kroki dia=graphviz,echo=FALSE}
digraph g {
rankdir="LR"
size="6,10"
edge[fontsize="24"]
node[shape=note,style=filled,fillcolor=cornsilk,height=2.2,width=1.5,fontsize=22]
Fu -> C[label=""]
Fu -> H[label="fut"]
H -> I[label="editor"]
I -> Wrap[label=" swig"]
Wrap -> SO[label="gcc"]
C -> SO[label=""]
Fu[label="Hello.Fu"]
C[label="hello.c"]
H[label="hello.h"]
I[label="hello.i"]
Wrap[label="hello_\nwrap.c"]
SO[label="hello.so"]
}
```

Let's have a look at an example interface file for Lua:

`include assets/hello.i {<pre> </pre>}`


Using the following command line we can create an hello shared library file on Linux:

```{.shell label=luaswigello,cmd="bash %i 2>&1 > %b.txt",chunk.ext=sh,ext=txt}
if [ ! -d swig-lua ]; then mkdir swig-lua ; fi
cp assets/hello.i swig-lua
fut -o swig-lua/hello.c assets/Hello.fu
cd swig-lua
swig -lua -module hello -o hello_wrap.c hello.i
gcc -fPIC -I/usr/include/lua5.1 -c  hello_wrap.c -o hello_wrap.o
gcc -fPIC -I/usr/include/lua5.1 -c  hello.c -o hello.o
gcc -shared -I/usr/include/lua5.1 -L/usr/lib/x86_64-linux-gnu/  hello_wrap.o hello.o -o hello.so
### check if there is the function in the shared library
nm hello.so | grep GetMessage
cd ..
```

We can now try to run that function in a Lua script. Here is an example script:

`include assets/run-hello.lua {<pre> </pre>}`

```{.shell label=luaswigrun,cmd="bash %i 2>&1 > %b.txt",chunk.ext=sh,ext=txt}
cp assets/run-hello.lua swig-lua/
cd swig-lua 
lua run-hello.lua
```

### Swig and Tcl

Let's repeat that example with the Tcl programming language. As this is as
well an interpreted language we will again compile a shared library to be
used by Tcl. The interface file looks like this:


`include assets/tcl-hello.i {<pre> </pre>}`

Let's now create a shared library file and then pipe some Tcl code into the
tclsh interpreter:

```{.shell label=tclswighello,cmd="bash %i 2>&1 > %b.txt",chunk.ext=sh,ext=txt}
if [ ! -d swig-tcl ]; then mkdir swig-tcl ; fi
cp assets/tcl-hello.i swig-tcl/hello.i
fut -o swig-tcl/hello.c assets/Hello.fu
cd swig-tcl
swig -tcl8 -module hello hello.i                ## create the interface wrap file
gcc -fPIC -c hello.c                            ## compile the FU generated code
gcc -fPIC -c hello_wrap.c -I/usr/include/tcl8.6 ## compile the SWIG generated code
gcc -shared hello.o hello_wrap.o -o hello.so    ## combine both to a Tcl library
echo "load ./hello.so; puts \"This is Tcl [set tcl_patchLevel]!\"; puts [Hello_GetMessage];" | tclsh
```

If you are interested in more example using Fusion with different language
targets have a look at the examples in the
[samples/hello](https://github.com/mittelmark/fusion-tutorial/samples/hello)
folder of the project.



## Data Types

The main basic data types in Fusion are boolean, int, float and double. For
int types as well exists byte, short, ushort and unint. Below you see how you
can create strings with embedded variable names. That does not work for
boolean values, so we create a help method BoolToInt which converts the
boolean value to an integer.
 
```{.shell label=Main2 cmd="fuscript %i > %b.txt" chunk.ext=fu ext=txt}
static class Main2 {
    public static int BoolToInt (bool b) {
        if (b) { return(1); }
        return(0);
    }
    public static void Main (string[] args) {
        int x = 3 ;
        bool b = true;  // bools can't be printed
        bool c = false;
        byte y = 12; 
        float f = 1.234;        
        Console.WriteLine($" x={x} b={Main2.BoolToInt(b)} c={Main2.BoolToInt(c)} y={y} f={f}");
    }   
}
```


As we did not prefix this class declaration with the public keyword that class will have an underscore in Python.

Here the output for the Python script :

`include Main2.py {{<pre class="py">} {</pre>}}` 

The output of the D language is not affected by the public keyword for the class.

## Type Conversions

Fusion does not support type conversions for instance from a string to an integer per default. But it can be implemented like this:


```{.shell label=Main3 cmd="fuscript %i > %b.txt" chunk.ext=fu ext=txt}
public static class Main3 {
    public static int BoolToInt (bool b) {
        if (b) { return(1); }
        return(0);
    }
    public static bool StringToBool (string b) {
        if (b.ToLower() == "true" || b == "1") {
            return(true);
        } else {
            return(false);
        }
    }
    public static void Main (string[] args) {
        string s1 = "true";
        bool b1 = Main3.StringToBool(s1);
        string s2 = "1";
        bool b2 = Main3.StringToBool(s2);
        string s3 = "false";
        bool b3 = Main3.StringToBool(s3);
        string s4 = "";
        bool b4 = Main3.StringToBool(s4);
        Console.WriteLine($"s1={BoolToInt(b1)} s2={BoolToInt(b2)}");
        Console.WriteLine($"s3={BoolToInt(b3)} s4={BoolToInt(b4)}");
    }   
}
```

## Parsing Integers

That problem is more serious. The main issue is what to do if we get an
invalid input. Usually an compile error, runtime error or exception is thrown
by the compiler or interpreter. That handling can be vary different. We solve
that problem here by returning an integer value which should be considered
invalid. That value in the following example has an value of -1 per default,
but these settings can be overwritten. Prefixing the call to ParseInt with
Main4 in the Main method is required for some languages like C++ to be
correctly calling the appropriate method.

### Python Output

Here is our next Fusion file to do some basic integer parsing and the expected output:.

```{.shell label=Main4 cmd="fuscript %i > %b.txt" chunk.ext=fu ext=txt}
public static class Main4 {
    public static int ParseInt(string s, int invalid=-1) {
        int def = -1;
        int i = 0;
        int multi = 1;
        string() s2;
        if (s.Length == 0) {
            return invalid;
        }
        if (s.StartsWith("-")) {
            multi = -1;
            s2=s.Substring(1);
        } else {
            s2 = s;
        }     
        foreach (int d in s2) {
            // finish at floats
            if (d == '.') {
                break;
            }
            if (d < '0' || d > '9') {
                return invalid;
            }    
            i = i * 10 + d - '0';
        }
        return i*multi;
    }
    public static void Main (string[] args) {
        string s1 = "12";
        int i1 = Main4.ParseInt(s1);
        string s2 = "-23";
        int i2 = Main4.ParseInt(s2);
        string s3 = "xyz";
        int i3 = Main4.ParseInt(s3);
        string s4 = "1234.5678";
        int i4 = Main4.ParseInt(s4);
        string s5 = "a1234.5678";
        int i5 = Main4.ParseInt(s5,-100);
        Console.WriteLine($"s1={s1} i1={i1}");
        Console.WriteLine($"s2={s2} i2={i2}");
        Console.WriteLine($"s3={s3} i3={i3}");
        Console.WriteLine($"s4={s4} i4={i4}");
        Console.WriteLine($"s5={s5} i5={i5}");        
    }   
}
```

That is the Python code which is generated by the command `fut Main4.fi -o Main4.py` and which was producing the output shown above:

`include Main4.py {<pre> </pre>}`

### D Output

In between we should check if as well other languages are working correctly
with the given code. Let's try first D and then C and C++.


```{.shell label=Main4 cmd="fut %i -o main4.d&&dmd main4.d -of=main4-d&&./main4-d > %b.txt" chunk.ext=fu ext=txt,echo=FALSE}
#INCLUDE "Main4.fu"
```

Let's have a look at the generated D code:

`include main4.d {<pre> </pre>}`

### C Output

We will now repeat the same with C, here the output of the C program:

```{.shell label=Main4 cmd="fut %i -o main4.c&&gcc main4.c -o main4-c&&./main4-c > %b.txt" chunk.ext=fu ext=txt,echo=FALSE}
#INCLUDE "Main4.fu"
```

Let's have a look at the generated C code:

`include main4.c {<pre> </pre>}`


And here the generated header file:

`include main4.h {<pre> </pre>}`

The generated code looks clean and nice to use later for using Swig to create library code for other languages. 

### C++ Output

But before we do this we repeat the procedure the same with C++, here the command to generate and compile the C++ code:

```
fut Main4.fu -o main4.cpp
g++ -std=c++20 main4.cpp -o main4-cpp
```

Please note that many features require a C++20 standard compliant compiler.

And here the generated C++ code:

```{.shell label=Main4 cmd="fut %i -o main4.cpp&&cat main4.cpp > %b.txt" chunk.ext=fu ext=txt,echo=FALSE}
#INCLUDE "Main4.fu"
```

And here the program output:

```{.shell label=Main4 cmd="fut %i -o main4.cpp&&g++ -std=c++20 main4.cpp -o main4-cpp&&./main4-cpp > %b.txt" chunk.ext=fu ext=txt,echo=FALSE}
#INCLUDE "Main4.fu"
```

## Native Language Code

That complicated approach to implement shown above for a feature which is probably available in all target
languages in a much more straightforward way, seems a little bit awkward. To use target language specific
functionalities you can instead embed code block within the native keyword.

Here an example for a _StringUtils_ class which uses this approach. To create
code in the target language you have than to call the _fut_ transpiler with a `-D` option like this:

```
fut -D PY StringUtils.fi -o stringutils.py
python3 stringutils.py
```

```{.shell label=StringUtils cmd="fut -D PY %i -o %b.py&&python3 %b.py >  %b.txt" chunk.ext=fu ext=txt}
#if D
native {
import std.conv;
}
#elif CPP
native {
#include <cstdlib>
#include <iostream>    
}
#endif
static class StringUtils 
{
	public static int parseInt (string input) 
	{
		int i = 0;
#if PY
		native {
		i=int(input);
		}
#elif D
	native {
		i=to!int(input);
	}
#elif CPP
	native {
		std::string s = {input.begin(), input.end()};
		i=std::atoi(s.c_str());
	}
#endif 
		return(i);
	}
}
class Main2 
{
	public static void Main (string[] args) 
	{
		int x = 3 ;
		float f = 1.234;	
		int z = 0 ;
		z = StringUtils.parseInt("12345");
		Console.WriteLine($" x={x} f={f} z={z}");
	}
}
```

The resulting Python file looks like this:

`include StringUtils.py {<pre> </pre>}`

> [!CAUTION]
> The tricky thing in implementing Python code is to achieve the proper indentation. 
> To accomplish this you should indent your code using <b>Tabstops!</b>. Only then then the structure can be recognized properly
> by the <i>fut</i> transpiler.

Let's look as well just for curiosity into the generated C++ code. That could
should be genrated and compiled using the following commands:


```{.shell label=compilecpp,cmd="bash %i > %b.txt" chunk.ext=sh ext=txt}
fut -D CPP StringUtils.fu -o stringutils.cpp
g++ -std=c++20 stringutils.cpp -o stringutils
./stringutils
```

Here the code generated by _fut_:

`include stringutils.cpp {<pre> </pre>}`

We leave the creation and execution of D code generated by fut as an exercise
for the reader.

## Using Swig to target other Programming Languages

TODO

## Documenting Code

TODO
